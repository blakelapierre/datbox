<html>
  <head>
    <title>dat box</title>

    <style>
      body {
        overflow: hidden;
      }
    </style>
  </head>
  <body>
    <script src="handler.js"></script>
    <script src="dat.gui.js"></script>
    <script src="mathbox-bundle.js"></script>

    <script type="mathbox/jsx">
      var x_min = 1, y_min = 1, props = {width: 32, height: 32};
      <root id="1">
        <camera id="2" proxy={true} position={[0, 0, 1]} />
        <matrix id="3" width={props.width} height={props.height} channels={2} expr={(emit, x, y, i, j, t) => {
          x = x + x_min;
          y = y + y_min;

          if (x !== 0 && y !== 0 && x % y === 0) emit(x, y);
        }} />
        <swizzle id="4" order="xyzw" />
        <cartesian id="5" range={[[1, props.width], [1, props.height], [1, 16]]} scale={[16/9, 1, 1]} position={[1.7725, 0, 0]}>
          <point id="6" color={[4/15, 0.68235, 0.85490]} size={1} blending="add" shape="square" opacity={4/5} fill={true} zWrite={false} zTest={false} />
        </cartesian>
      </root>

      setInterval(function() { x_min, y_min, props.width++, props.height++; }, 100);
    </script>

    <script type="application/es2015">
    'use strict';

    class CameraControls {
      constructor(camera) {
        this.camera = camera;

        this.fov = 60;
        this.lookAt = [0, 0, 0];
        this.position = [0, 0, 1];
        this.proxy = true;
      }

      set(name, value) {
        this.camera.set(name, value);
      }
    }

    class BoxControls {
      constructor(root, updateProjection, viewControls) {
        this.root = root;
        this.updateProjection = updateProjection; // ugly
        this.viewControls = viewControls; // ugly

        this.xMin = 1;
        this.yMin = 1;
        this.width = Math.pow(2, 5);
        this.height = Math.pow(2, 4);
      }

      set(name, value) {
        const {root, xMin, yMin, width, height} = this,
              view = root.select(this.viewControls.projection),
              matrix = root.select('matrix');

        view.set('range', [
          [xMin, xMin + width - 1],
          [yMin, yMin + height - 1],
          [yMin, yMin + height - 1]
        ]);

        // matrix.expr = divisors(xMin, yMin);
        matrix.set('expr', divisors(xMin, yMin));

        matrix.set('width', width);
        matrix.set('height', height);
        matrix.set('bufferWidth', width);
        matrix.set('bufferHeight', height);

        this.updateProjection(); // How can this be gotten rid of?
      }
    }

    class ViewControls {
      constructor(root, updateProjection) {
        this.root = root;
        this.updateProjection = updateProjection;

        this.projection = 'cartesian';

        this.bend = 1;
        this.helix = false;
        this.helixValue = 0.0001;
      }

      set(name, value) {
        switch(name) {
          case 'projection': this.updateProjection(); break;

          case 'bend': this.updateBend(); break;
          case 'helix':
          case 'helixValue': this.updateHelixValue(); break;
        }
      };

      updateBend() {
        const {root, bend} = this,
              polar = root.select('polar');

        if (polar) polar.set('bend', bend);
      }

      updateHelixValue() {
        const {root, helix, helixValue} = this,
              polar = root.select('polar');

        if (polar) polar.set('helix', helix ? helixValue : 0);
      }
    }

    class PointControls {
      constructor(root) {
        this.root = root;

        this.size = 1;
        this.opacity = 0.8;
        this.blending = 'add';
        this.color = [68, 174, 218];
        this.shape = 'square';
        this.fill = true;
      }

      set(name, value) {
        const {root} = this,
              point = root.select('point');

        if (name === 'color') value = value.map(v => v / 255);

        point.set(name, value);
      }

      updater(type) {
        return (name, fn) => {
          const element = view.select(type);

          element.set(name, fn ? fn(this[name]) : this[name]);
        };
      }
    }

      const comm = new Comm();
      // setupDatGui(setupMathbox(comm));

      function setupDatGui({boxControls, viewControls, pointControls, cameraControls}) {
        const gui = new dat.GUI();

        const parameters = gui.addFolder('Parameters'),
              box = addFolder(parameters, 'Box', boxControls),
              projection = addFolder(parameters, 'Projection', viewControls),
              point = addFolder(gui, 'Point', pointControls),
              camera = addFolder(gui, 'Camera', cameraControls);

        const x = {min: -Math.pow(2, 8), max: Math.pow(2, 8), step: 1},
              y = {min: -Math.pow(2, 8), max: Math.pow(2, 8), step: 1},
              w = {min: 1, max: Math.pow(2, 14), step: 1},
              h = {min: 1, max: Math.pow(2, 12), step: 1};

        const boxControllers = box.add([
          ['xMin', x.min, x.max, x.step],
          ['yMin', y.min, y.max, y.step],
          ['width', w.min, w.max, w.step],
          ['height', h.min, h.max, h.step],
        ]);

        projection.add([
          ['projection', {'Cartesian': 'cartesian', 'Polar': 'polar', 'Spherical': 'spherical'}]
        ]);

        let polarOptions;
        comm.on('showPolarOptions', (helix, helixValue) => {
          if (polarOptions === undefined) {
            polarOptions = projection.add([
              ['bend', 0.001, 10, 0.001],
              ['helix', helix],
              ['helixValue', 0.001, 2, 0.001]
            ]);
          }
        });

        comm.on('hidePolarOptions', () => {
          const {folder} = projection,
                controllers = folder.__controllers,
                {length} = controllers;

          if (polarOptions) {
            //big hack
            for (let i = length - 1; i >= length - polarOptions.length; i--) folder.remove(controllers[i]);
            polarOptions = undefined;
          }
        });

        point.add([
          ['size', 1, 10, 1],
          ['opacity', 0, 1, 0.01],
          ['blending', ['no', 'normal', 'add', 'multiply', 'subtract']],
          ['shape', ['circle', 'square', 'diamond', 'up', 'down', 'left', 'right']],
          ['fill', false],
          ['color']
        ]);

        camera.add([
          ['fov', 0, 360, 1]
        ]);

        [point, box, projection, camera].forEach( b => open(b.folder));
        parameters.open();

        gui.remember(boxControls, viewControls, pointControls);

        function addFolder(parent, name, controller) {
          const folder = parent.addFolder(name);

          return {folder, add};

          function add(items) {
            return items.map(addItem);

            function addItem(params) {
              if (params.length > 2) {
                const [name, min, max, step] = params;
                return folder.add(controller, name, min, max).step(step).onChange(update(name));
              }
              else if (params.length === 2) {
                const [name, options] = params;
                return folder.add(controller, name, options).onChange(update(name));
              }
              else if (params.length === 1) {
                const [name] = params;
                return folder.addColor(controller, name).onChange(update(name));
              }
            }
          }

          function update(name) {
            return value => controller.set(name, value);
          }
        }

        function open(folder) { folder.open(); }
      }

      function setupMathbox(comm) {

        const mathbox = mathBox({
          plugins: ['core', 'controls', 'cursor', 'stats'],
          controls: {
            klass: THREE.OrbitControls
          },
        });

        const {three} = mathbox;

        three.renderer.setClearColor(new THREE.Color(0x000000), 1.0);

        const camera = mathbox.camera({
          proxy: true,
          position: [0, 0, 1]
        });

        const viewControls = new ViewControls(mathbox, updateProjection),
              boxControls = new BoxControls(mathbox, updateProjection, viewControls),
              pointControls = new PointControls(mathbox);

        var matrix = constructMatrix(boxControls),
            view = constructView(); // Babel transpilation of this errors with `let`...not sure that is right

        const cameraControls = new CameraControls(camera);

        return {boxControls, viewControls, pointControls, cameraControls};

        function constructMatrix({xMin, yMin, width, height}) {
          return mathbox.matrix({
              width: width,
              height: height,
              channels: 2,
              expr: divisors(xMin, yMin),
            })
            .swizzle({
              order: 'xyyx'
            });
        }

        function constructView() {
          const projections = {
            'cartesian': {
              scale: (width, height) => [16/9, 1, 1]
            },
            'polar': {
              x: (min, max) => [min, max],
              range: (x_min, x_max, y_min, y_max, z_min, z_max) =>
                [
                  [x_min, x_max],
                  [y_min, y_max],
                  [z_min, z_max]
                ],
              scale: (width, height) => [16/9, 1, 1]
            },
            'spherical': {
              x: (min, max) => [min, Math.sqrt(max)],
              range: (x_min, x_max, y_min, y_max, z_min, z_max) =>
                [
                  [x_min, x_max],
                  [Math.sqrt(y_min), Math.sqrt(y_max)],
                  [Math.round(Math.sqrt(Math.abs(z_min))), Math.round(Math.sqrt(Math.abs(z_max)))]
                ],
              scale: (width, height) => [16/9, 1, 1]
            }
          };

          const {xMin, yMin, width, height} = boxControls,
                {bend, helix, helixValue, projection} = viewControls,
                {color, size, blending, shape, opacity, fill} = pointControls;


          view = buildView(matrix, {
            projection,
            xMin,
            yMin,
            xMax: xMin + width - 1,
            yMax: yMin + height - 1,
            helix,
            bend,
            helixValue
          });

          view
            .point({
              color: color.map(v => v / 255),
              size,
              blending,
              shape,
              opacity,
              fill,
              zWrite: false,
              zTest: false,
            });

          return view;

          function buildView(view, config) {
            let {projection: name,
                 xMin: x_min, xMax: x_max,
                 yMin: y_min, yMax: y_max,
                 bend, helix, helixValue} = config;

            let z_min = y_min,
                z_max = y_max;

            const {range, scale, z} = projections[name];

            if (z) {
              const transformed = z(z_min, z_max);

              z_min = transformed[0];
              z_max = transformed[1];
            }

            if (range) {
              const r = range(x_min, x_max, y_min, y_max, z_min, z_max);

              x_min = r[0][0];
              x_max = r[0][1];
              y_min = r[1][0];
              y_max = r[1][1];
              z_min = r[2][0];
              z_max = r[2][1];
            }

            const width = x_max - x_min + 1,
                  height = y_max - y_min + 1;
            const options = {
              range: [[x_min, x_max], [y_min, y_max], [z_min, z_max]],
              scale: scale ? scale(width, height) : [1, 1, 1],
              position: [Math.sqrt(Math.PI), 0, 0],
            };

            if (name === 'polar') {
              if (helix) options.helix = helixValue;
              options.bend = bend;
            }
            if (name === 'spherical') {
              options.eulerOrder = 'zxy';
            }

            return view[name](options);
          }
        }

        function updateProjection() {
          updateDatGui();
          updateView();

          function updateDatGui() {
            if (viewControls.projection === 'polar') showPolarOptions();
            else hidePolarOptions();

            function showPolarOptions() {
              comm.emit('showPolarOptions');
            }

            function hidePolarOptions() {
              comm.emit('hidePolarOptions');
            }
          }

          function updateView() {
            view.remove();
            constructView();
          }
        }
      }

      function divisors(x_min, y_min) {
        return (emit, x, y, i, j, t) => {
          x = x + x_min;
          y = y + y_min;

          if (x !== 0 && y !== 0 && x % y === 0) emit(x, y);
        };
      }

      function Comm() {
        const listeners = [];

        this.emit = name => (listeners[name] || []).forEach(notify);

        this.on = (name, fn) => (listeners[name] = listeners[name] || []).push(fn);

        function notify(fn) {
          fn();
        }
      }
    </script>
  </body>
</html>