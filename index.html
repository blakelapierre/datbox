<html>
  <head>
    <title>dat box</title>

    <style>
      body {
        overflow: hidden;
      }
    </style>
  </head>
  <body>
    <script src="dat.gui.js"></script>
    <script src="mathbox-bundle.js"></script>

    <script>
      setupDatGui(setupMathbox());

      function setupDatGui(controls) {
        var gui = new dat.GUI();

        var parameters = gui.addFolder('Parameters'),
            display = gui.addFolder('Display'),
            box = parameters.addFolder('Box'),
            projection = parameters.addFolder('Projection');

        var x = {min: -Math.pow(2, 8), max: Math.pow(2, 8), step: 1},
            y = {min: -Math.pow(2, 8), max: Math.pow(2, 8), step: 1},
            w = {min: 1, max: Math.pow(2, 14), step: 1},
            h = {min: 1, max: Math.pow(2, 12), step: 1};

        add(box, [
          ['xMin', x.min, x.max, x.step],
          ['yMin', y.min, y.max, y.step],
          ['width', w.min, w.max, w.step],
          ['height', h.min, h.max, h.step],
        ]);

        add(projection, [
          ['projection', ['Cartesian', 'Polar', 'Spherical']]
        ]);


        add(display, [
          ['pointSize', 1, 10, 1],
          ['color']
        ]);

        parameters.open();
        display.open();
        box.open();
        projection.open();

        gui.remember(controls);

        function add(folder, items) {
          items.forEach(function(item) { addItem.apply(null, item); });

          function addItem(name) {
            if (arguments.length > 2) {
              var min = arguments[1], max = arguments[2], step = arguments[3];
              folder.add(controls, name, min, max).step(step).onChange(update(name));
            }
            else if (arguments.length === 2) {
              var options = arguments[1];
              folder.add(controls, name, options).onChange(update(name));
            }
            else if (arguments.length === 1) {
              folder.addColor(controls, name).onChange(update(name));
            }
          }
        }

        function update(name) {
          return function(value) {
            controls.set(name, value);
          };
        }
      }

      function setupMathbox() {

        var mathbox = mathBox({
          plugins: ['core', 'controls', 'cursor', 'stats'],
          controls: {
            klass: THREE.OrbitControls
          },
        });

        var three = mathbox.three;

        three.renderer.setClearColor(new THREE.Color(0x000000), 1.0);

        var camera = mathbox.camera({
          proxy: true,
          position: [0, 0, 1]
        });

        var controls = new Controls();

        var view = buildProjection(controls.projection, controls.xMin, controls.xMin + controls.width - 1, controls.yMin, controls.yMin + controls.height - 1, false, 1);

        view
          .matrix({
            width: controls.width,
            height: controls.height,
            channels: 3,
            expr: divisors(controls.xMin, controls.yMin),
          })
          .point({
            color: controls.color.map(function(v) { return v / 255; }),
            size: controls.pointSize,
            blending: 'add',
            shape: 'square',
            opacity: 0.8,
            zWrite: false,
            zTest: false,
          });

        function divisors(x_min, y_min) {
          return (emit, x, y, i, j, t) => {
            x = x + x_min;
            y = y + y_min;

            if (x !== 0 && y !== 0 && x % y === 0) emit(x, y, 2);
          };
        }

        return controls;

        function Controls() {
          this.xMin = 1;
          this.yMin = 1;
          this.width = Math.pow(2, 5);
          this.height = Math.pow(2, 4);

          this.projection = 'Cartesian';

          this.pointSize = 1;
          this.color = [68, 174, 218];

          this.set = function(name, value) {
            console.log('set', name, value, this);
            switch(name) {
              case 'xMin':
              case 'yMin':
              case 'width':
              case 'height': updateRange(); break;

              case 'projection': updateProjection(); break;

              case 'color': updateColor(); break;
              case 'pointSize': updatePointSize(); break;
            }
          };
        }

        function updateRange() {
          view[0].set('range', [
            [controls.xMin, controls.xMin + controls.width - 1],
            [controls.yMin, controls.yMin + controls.height - 1],
            [controls.yMin, controls.yMin + controls.height - 1]
          ]);

          view.select('matrix').set('width', controls.width);
          view.select('matrix').set('height', controls.height);
        }

        function updateProjection() {
          console.log(view);
          view.remove();

          view = buildProjection(controls.projection, controls.xMin, controls.xMin + controls.width - 1, controls.yMin, controls.yMin + controls.height - 1, false, 1);

          view
            .matrix({
              width: controls.width,
              height: controls.height,
              channels: 3,
              expr: divisors(controls.xMin, controls.yMin),
            })
            .point({
              color: controls.color.map(function(v) { return v / 255; }),
              size: controls.pointSize,
              blending: 'add',
              shape: 'square',
              opacity: 0.8,
              zWrite: false,
              zTest: false,
            });

          // console.log(newView, view.select('matrix'));
          // newView[0].add(view.select('matrix')[0]);
          // newView[0].add(view.select('point')[0]);
          // console.log(newView, view.select('matrix'));
        }

        function updateColor() {
          view.select('point').set('color', controls.color.map(function(v) { return v / 255; }));
        }

        function updatePointSize() {
          view.select('point').set('size', controls.pointSize);
        }













        function buildProjection(name, x_min, x_max, y_min, y_max, helix, helixValue) {
          var projections = {
            'Cartesian': {
              scale: function(width, height) { return [16/9, 1, 1]; }
            },
            'Polar': {
              // x: function(min, max) { return [min, Math.sqrt(max)]; },
              x: function(min, max) { return [min, max]; },
              range: function(x_min, x_max, y_min, y_max, z_min, z_max) {
                return [
                  [x_min, x_max],
                  [y_min, y_max],
                  [z_min, z_max]
                ];
              },
              scale: function(width, height) { return [16/9, 1, 1]; },
              helix: 0.01
            },
            'Spherical': {
              x: function(min, max) { return [min, Math.sqrt(max)]; },
              range: function(x_min, x_max, y_min, y_max, z_min, z_max) {
                return [
                  [x_min, x_max],
                  [Math.sqrt(y_min), Math.sqrt(y_max)],
                  [Math.round(Math.sqrt(Math.abs(z_min))), Math.round(Math.sqrt(Math.abs(z_max)))]
                ];
              },
              scale: function(width, height) {
                return [16/9, 1, 1];
              }
            }
          };

          var z_min = y_min,
              z_max = y_max;

          var projection = projections[name];

          if (projection.z) {
            var transformed = projection.z(z_min, z_max);

            z_min = transformed[0];
            z_max = transformed[1];
          }

          if (projection.range) {
            var range = projection.range(x_min, x_max, y_min, y_max, z_min, z_max);

            x_min = range[0][0];
            x_max = range[0][1];
            y_min = range[1][0];
            y_max = range[1][1];
            z_min = range[2][0];
            z_max = range[2][1];
          }

          var width = x_max - x_min + 1,
                height = y_max - y_min + 1;
          var options = {
            range: [[x_min, x_max], [y_min, y_max], [z_min, z_max]],
            scale: projection.scale ? projection.scale(width, height) : [1, 1, 1],
            position: [Math.sqrt(Math.PI), 0, 0],
          };

          if (name === 'polar' && helix) {
            options.helix = projection.helix;
            options.helix = helixValue;
          }

          console.log('build', helix, options);

          return mathbox[name.toLowerCase()](options);
        }
      }

      function divisors(x_min, y_min) {
        return (emit, x, y, i, j, t) => {
          x = x + x_min;
          y = y + y_min;

          if (x !== 0 && y !== 0 && x % y === 0) emit(x, y, 2);
        };
      }
    </script>
  </body>
</html>