<html>
  <head>
    <title>dat box</title>

    <style>
      body {
        overflow: hidden;
      }
    </style>
  </head>
  <body>
    <!-- <script src="babel-core.js"></script> -->
    <script src="es2015handler.js"></script>
    <script src="dat.gui.js"></script>
    <script src="mathbox-bundle.js"></script>

    <script type="application/es2015">
    'use strict';

      const comm = new Comm();
      setupDatGui(setupMathbox(comm));

      function setupDatGui(controls) {
        const gui = new dat.GUI();

        const parameters = gui.addFolder('Parameters'),
              point = gui.addFolder('Point'),
              box = parameters.addFolder('Box'),
              projection = parameters.addFolder('Projection');

        const x = {min: -Math.pow(2, 8), max: Math.pow(2, 8), step: 1},
              y = {min: -Math.pow(2, 8), max: Math.pow(2, 8), step: 1},
              w = {min: 1, max: Math.pow(2, 14), step: 1},
              h = {min: 1, max: Math.pow(2, 12), step: 1};

        const boxControllers = add(box, [
          ['xMin', x.min, x.max, x.step],
          ['yMin', y.min, y.max, y.step],
          ['width', w.min, w.max, w.step],
          ['height', h.min, h.max, h.step],
        ]);

        add(projection, [
          ['projection', ['Cartesian', 'Polar', 'Spherical']]
        ]);

        let polarOptions;
        comm.on('showPolarOptions', (helix, helixValue) => {
          if (polarOptions === undefined) {
            polarOptions = add(projection, [
              ['bend', 0.0001, 10, 0.0001],
              ['helix', helix],
              ['helixValue', 0.0001, 2, 0.0001]
            ]);
          }
        });

        comm.on('hidePolarOptions', () => {
          const controllers = projection.__controllers,
                {length} = controllers;

          if (polarOptions) {
            //big hack
            for (let i = length - 1; i >= length - polarOptions.length; i--) projection.remove(controllers[i]);
            polarOptions = undefined;
          }
        });

        add(point, [
          ['size', 1, 10, 1],
          ['opacity', 0, 1, 0.01],
          ['blending', ['no', 'normal', 'add', 'multiply', 'subtract']],
          ['shape', ['circle', 'square', 'diamond', 'up', 'down', 'left', 'right']],
          ['fill', false],
          ['color']
        ]);

        [parameters, point, box, projection].forEach(open);

        gui.remember(controls);

        function add(folder, items) {
          return items.map(addItem);

          function addItem(params) {
            if (params.length > 2) {
              const [name, min, max, step] = params;
              return folder.add(controls, name, min, max).step(step).onChange(update(name));
            }
            else if (params.length === 2) {
              const [name, options] = params;
              return folder.add(controls, name, options).onChange(update(name));
            }
            else if (params.length === 1) {
              const [name] = params;
              return folder.addColor(controls, name).onChange(update(name));
            }
          }
        }

        function open(folder) { folder.open(); }

        function update(name) {
          return value => controls.set(name, value);
        }
      }

      function setupMathbox(comm) {

        const mathbox = mathBox({
          plugins: ['core', 'controls', 'cursor', 'stats'],
          controls: {
            klass: THREE.OrbitControls
          },
        });

        const {three} = mathbox;

        three.renderer.setClearColor(new THREE.Color(0x000000), 1.0);

        const camera = mathbox.camera({
          proxy: true,
          position: [0, 0, 1]
        });

        const controls = new Controls();

        var view = constructView(controls); // Babel transpilation of this errors with `let`...not sure that is right

        return controls;

        function Controls() {
          this.xMin = 1;
          this.yMin = 1;
          this.width = Math.pow(2, 5);
          this.height = Math.pow(2, 4);

          this.projection = 'Cartesian';

          this.bend = 1;
          this.helix = false;
          this.helixValue = 0.0001;

          this.size = 1;
          this.opacity = 0.8;
          this.blending = 'add';
          this.color = [68, 174, 218];
          this.shape = 'square';
          this.fill = true;

          const pointUpdater = updater('point');

          this.set = (name, value) => {
            switch(name) {
              case 'xMin':
              case 'yMin':
              case 'width':
              case 'height': updateBox(); break;

              case 'projection': updateProjection(); break;

              case 'bend': updateBend(); break;
              case 'helix': updateHelix(); break;
              case 'helixValue': updateHelixValue(); break;

              case 'size': pointUpdater('size'); break;
              case 'opacity': pointUpdater('opacity'); break;
              case 'blending': pointUpdater('blending'); break;
              case 'color': mapped(pointUpdater, 'color', function(v) { return v / 255; }); break;
              case 'shape': pointUpdater('shape'); break;
              case 'fill': pointUpdater('fill'); break;
            }
          };

          function updateBox() {
            view[0].set('range', [
              [controls.xMin, controls.xMin + controls.width - 1],
              [controls.yMin, controls.yMin + controls.height - 1],
              [controls.yMin, controls.yMin + controls.height - 1]
            ]);

            const matrix = view.select('matrix');

            matrix.expr = divisors(controls.xMin, controls.yMin);

            matrix.set('width', controls.width);
            matrix.set('height', controls.height);

            matrix.evaluate('expr');

            updateProjection(); // How can this be gotten rid of?
          }

          function updateProjection() {
            updateDatGui();
            updateView();

            function updateDatGui() {
              if (controls.projection === 'Polar') showPolarOptions();
              else hidePolarOptions();

              function showPolarOptions() {
                comm.emit('showPolarOptions');
              }

              function hidePolarOptions() {
                comm.emit('hidePolarOptions');
              }
            }

            function updateView() {
              view.remove();
              constructView();
            }
          }

          function updateBend() {
            if (view[0].type === 'polar') {
              view[0].set('bend', controls.bend);
            }
          }

          function updateHelix() {
            updateHelixValue();
          }

          function updateHelixValue() {
            if (view[0].type === 'polar') {
              view[0].set('helix', controls.helix ? controls.helixValue : 0);
            }
          }

          function updater(type) {
            return (name, fn) => {
              const element = view.select(type);

              element.set(name, fn ? fn(controls[name]) : controls[name]);
            };
          }

          function mapped(updater, name, fn) {
            return updater(name, items => items.map(fn));
          }
        }

        function constructView() {
          const projections = {
            'cartesian': {
              scale: (width, height) => [16/9, 1, 1]
            },
            'polar': {
              x: (min, max) => [min, max],
              range: (x_min, x_max, y_min, y_max, z_min, z_max) =>
                [
                  [x_min, x_max],
                  [y_min, y_max],
                  [z_min, z_max]
                ],
              scale: (width, height) => [16/9, 1, 1]
            },
            'spherical': {
              x: (min, max) => [min, Math.sqrt(max)],
              range: (x_min, x_max, y_min, y_max, z_min, z_max) =>
                [
                  [x_min, x_max],
                  [Math.sqrt(y_min), Math.sqrt(y_max)],
                  [Math.round(Math.sqrt(Math.abs(z_min))), Math.round(Math.sqrt(Math.abs(z_max)))]
                ],
              scale: (width, height) => [16/9, 1, 1]
            }
          };

          const matrix = mathbox.matrix({
              width: controls.width,
              height: controls.height,
              channels: 3,
              expr: divisors(controls.xMin, controls.yMin),
            });

          view = buildView(matrix, {
            projection: controls.projection.toLowerCase(),
            xMin: controls.xMin,
            yMin: controls.yMin,
            xMax: controls.xMin + controls.width - 1,
            yMax: controls.yMin + controls.height - 1,
            helix: controls.helix,
            bend: controls.bend,
            helixValue: controls.helixValue
          });

          view
            .point({
              color: controls.color.map(v => v / 255),
              size: controls.size,
              blending: controls.blending,
              shape: controls.shape,
              opacity: controls.opacity,
              fill: controls.fill,
              zWrite: false,
              zTest: false,
            });

          return view;

          function buildView(view, config) {
            let {projection: name,
                 xMin: x_min, xMax: x_max,
                 yMin: y_min, yMax: y_max,
                 helix, helixValue} = config;

            let z_min = y_min,
                z_max = y_max;

            const projection = projections[name];
            const {range, scale, z} = projections[name];

            if (z) {
              const transformed = z(z_min, z_max);

              z_min = transformed[0];
              z_max = transformed[1];
            }

            if (range) {
              const r = range(x_min, x_max, y_min, y_max, z_min, z_max);

              x_min = r[0][0];
              x_max = r[0][1];
              y_min = r[1][0];
              y_max = r[1][1];
              z_min = r[2][0];
              z_max = r[2][1];
            }

            const width = x_max - x_min + 1,
                  height = y_max - y_min + 1;
            const options = {
              range: [[x_min, x_max], [y_min, y_max], [z_min, z_max]],
              scale: scale ? scale(width, height) : [1, 1, 1],
              position: [Math.sqrt(Math.PI), 0, 0],
            };

            if (name === 'polar' && helix) {
              options.helix = helixValue;
            }

            return view[name](options);
          }
        }
      }

      function divisors(x_min, y_min) {
        return (emit, x, y, i, j, t) => {
          x = x + x_min;
          y = y + y_min;

          if (x !== 0 && y !== 0 && x % y === 0) emit(x, y, y / Math.sqrt(x));
        };
      }

      function Comm() {
        const listeners = [];

        this.emit = name => (listeners[name] || []).forEach(notify);

        this.on = (name, fn) => (listeners[name] = listeners[name] || []).push(fn);

        function notify(fn) {
          fn();
        }
      }
    </script>
  </body>
</html>