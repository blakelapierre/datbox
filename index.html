<html>
  <head>
    <title>dat box</title>

    <style>
      body {
        overflow: hidden;
      }
    </style>
  </head>
  <body>
    <!-- <script src="babel-core.js"></script> -->
    <script src="es2015handler.js"></script>
    <script src="dat.gui.js"></script>
    <script src="mathbox-bundle.js"></script>

    <script type="application/es2015">
    'use strict';

      const comm = new Comm();
      setupDatGui(setupMathbox(comm));

      function setupDatGui({boxControls, viewControls, pointControls}) {
        const gui = new dat.GUI();

        const parameters = gui.addFolder('Parameters'),
              box = addFolder(parameters, 'Box', boxControls),
              projection = addFolder(parameters, 'Projection', viewControls),
              point = addFolder(gui, 'Point', pointControls);

        const x = {min: -Math.pow(2, 8), max: Math.pow(2, 8), step: 1},
              y = {min: -Math.pow(2, 8), max: Math.pow(2, 8), step: 1},
              w = {min: 1, max: Math.pow(2, 14), step: 1},
              h = {min: 1, max: Math.pow(2, 12), step: 1};

        const boxControllers = box.add([
          ['xMin', x.min, x.max, x.step],
          ['yMin', y.min, y.max, y.step],
          ['width', w.min, w.max, w.step],
          ['height', h.min, h.max, h.step],
        ]);

        projection.add([
          ['projection', ['Cartesian', 'Polar', 'Spherical']]
        ]);

        let polarOptions;
        comm.on('showPolarOptions', (helix, helixValue) => {
          if (polarOptions === undefined) {
            polarOptions = projection.add([
              ['bend', 0.0001, 10, 0.0001],
              ['helix', helix],
              ['helixValue', 0.0001, 2, 0.0001]
            ]);
          }
        });

        comm.on('hidePolarOptions', () => {
          const {folder} = projection,
                controllers = folder.__controllers,
                {length} = controllers;

          if (polarOptions) {
            //big hack
            for (let i = length - 1; i >= length - polarOptions.length; i--) folder.remove(controllers[i]);
            polarOptions = undefined;
          }
        });

        point.add([
          ['size', 1, 10, 1],
          ['opacity', 0, 1, 0.01],
          ['blending', ['no', 'normal', 'add', 'multiply', 'subtract']],
          ['shape', ['circle', 'square', 'diamond', 'up', 'down', 'left', 'right']],
          ['fill', false],
          ['color']
        ]);

        [point, box, projection].forEach( b => open(b.folder));
        parameters.open();

        gui.remember(boxControls, viewControls, pointControls);

        function addFolder(parent, name, controller) {
          const folder = parent.addFolder(name);

          return {folder, add};

          function add(items) {
            return items.map(addItem);

            function addItem(params) {
              if (params.length > 2) {
                const [name, min, max, step] = params;
                return folder.add(controller, name, min, max).step(step).onChange(update(name));
              }
              else if (params.length === 2) {
                const [name, options] = params;
                return folder.add(controller, name, options).onChange(update(name));
              }
              else if (params.length === 1) {
                const [name] = params;
                return folder.addColor(controller, name).onChange(update(name));
              }
            }
          }

          function update(name) {
            return value => controller.set(name, value);
          }
        }

        function open(folder) { folder.open(); }
      }

      function setupMathbox(comm) {

        const mathbox = mathBox({
          plugins: ['core', 'controls', 'cursor', 'stats'],
          controls: {
            klass: THREE.OrbitControls
          },
        });

        const {three} = mathbox;

        three.renderer.setClearColor(new THREE.Color(0x000000), 1.0);

        const camera = mathbox.camera({
          proxy: true,
          position: [0, 0, 1]
        });

        const boxControls = new BoxControls(),
              viewControls = new ViewControls(),
              pointControls = new PointControls();

        var view = constructView(boxControls, viewControls); // Babel transpilation of this errors with `let`...not sure that is right

        return {boxControls, viewControls, pointControls};

        function BoxControls() {
          this.xMin = 1;
          this.yMin = 1;
          this.width = Math.pow(2, 5);
          this.height = Math.pow(2, 4);

          this.set = (name, value) => {
            switch(name) {
              case 'xMin':
              case 'yMin':
              case 'width':
              case 'height': updateBox.apply(this); break;
            }
          }

          function updateBox() {
            view[0].set('range', [
              [this.xMin, this.xMin + this.width - 1],
              [this.yMin, this.yMin + this.height - 1],
              [this.yMin, this.yMin + this.height - 1]
            ]);

            const matrix = view.select('matrix');

            matrix.expr = divisors(this.xMin, this.yMin);

            matrix.set('width', this.width);
            matrix.set('height', this.height);

            // matrix.evaluate('expr');

            updateProjection(); // How can this be gotten rid of?
          }
        }

        function ViewControls() {
          this.projection = 'Cartesian';

          this.bend = 1;
          this.helix = false;
          this.helixValue = 0.0001;

          this.set = (name, value) => {
            switch(name) {
              case 'projection': updateProjection(); break;

              case 'bend': updateBend.apply(this); break;
              case 'helix':
              case 'helixValue': updateHelixValue.apply(this); break;
            }
          };

          function updateBend() {
            if (view[0].type === 'polar') {
              view[0].set('bend', this.bend);
            }
          }

          function updateHelixValue() {
            if (view[0].type === 'polar') {
              view[0].set('helix', this.helix ? this.helixValue : 0);
            }
          }
        }

        function PointControls() {
          const pointUpdater = updater.call(this, 'point');

          this.size = 1;
          this.opacity = 0.8;
          this.blending = 'add';
          this.color = [68, 174, 218];
          this.shape = 'square';
          this.fill = true;

          this.set = (name, value) => {
            switch(name) {
              case 'size': pointUpdater('size'); break;
              case 'opacity': pointUpdater('opacity'); break;
              case 'blending': pointUpdater('blending'); break;
              case 'color': mapped(pointUpdater, 'color', v => v / 255); break;
              case 'shape': pointUpdater('shape'); break;
              case 'fill': pointUpdater('fill'); break;
            }
          };

          function updater(type) {
            return (name, fn) => {
              const element = view.select(type);

              element.set(name, fn ? fn(this[name]) : this[name]);
            };
          }

          function mapped(updater, name, fn) {
            return updater(name, items => items.map(fn));
          }
        }

        function updateProjection() {
          updateDatGui();
          updateView();

          function updateDatGui() {
            if (viewControls.projection === 'Polar') showPolarOptions();
            else hidePolarOptions();

            function showPolarOptions() {
              comm.emit('showPolarOptions');
            }

            function hidePolarOptions() {
              comm.emit('hidePolarOptions');
            }
          }

          function updateView() {
            view.remove();
            constructView();
          }
        }

        function constructView() {
          const projections = {
            'cartesian': {
              scale: (width, height) => [16/9, 1, 1]
            },
            'polar': {
              x: (min, max) => [min, max],
              range: (x_min, x_max, y_min, y_max, z_min, z_max) =>
                [
                  [x_min, x_max],
                  [y_min, y_max],
                  [z_min, z_max]
                ],
              scale: (width, height) => [16/9, 1, 1]
            },
            'spherical': {
              x: (min, max) => [min, Math.sqrt(max)],
              range: (x_min, x_max, y_min, y_max, z_min, z_max) =>
                [
                  [x_min, x_max],
                  [Math.sqrt(y_min), Math.sqrt(y_max)],
                  [Math.round(Math.sqrt(Math.abs(z_min))), Math.round(Math.sqrt(Math.abs(z_max)))]
                ],
              scale: (width, height) => [16/9, 1, 1]
            }
          };

          const {xMin, yMin, width, height} = boxControls,
                {bend, helix, helixValue, projection} = viewControls,
                {color, size, blending, shape, opacity, fill} = pointControls;

          const matrix = mathbox.matrix({
              width: width,
              height: height,
              channels: 3,
              expr: divisors(xMin, yMin),
            });

          view = buildView(matrix, {
            projection: projection.toLowerCase(),
            xMin,
            yMin,
            xMax: xMin + width - 1,
            yMax: yMin + height - 1,
            helix,
            bend,
            helixValue
          });

          view
            .point({
              color: color.map(v => v / 255),
              size,
              blending,
              shape,
              opacity,
              fill,
              zWrite: false,
              zTest: false,
            });

          return view;

          function buildView(view, config) {
            let {projection: name,
                 xMin: x_min, xMax: x_max,
                 yMin: y_min, yMax: y_max,
                 helix, helixValue} = config;

            let z_min = y_min,
                z_max = y_max;

            const projection = projections[name];
            const {range, scale, z} = projections[name];

            if (z) {
              const transformed = z(z_min, z_max);

              z_min = transformed[0];
              z_max = transformed[1];
            }

            if (range) {
              const r = range(x_min, x_max, y_min, y_max, z_min, z_max);

              x_min = r[0][0];
              x_max = r[0][1];
              y_min = r[1][0];
              y_max = r[1][1];
              z_min = r[2][0];
              z_max = r[2][1];
            }

            const width = x_max - x_min + 1,
                  height = y_max - y_min + 1;
            const options = {
              range: [[x_min, x_max], [y_min, y_max], [z_min, z_max]],
              scale: scale ? scale(width, height) : [1, 1, 1],
              position: [Math.sqrt(Math.PI), 0, 0],
            };

            if (name === 'polar' && helix) {
              options.helix = helixValue;
            }

            return view[name](options);
          }
        }
      }

      function divisors(x_min, y_min) {
        return (emit, x, y, i, j, t) => {
          x = x + x_min;
          y = y + y_min;

          if (x !== 0 && y !== 0 && x % y === 0) emit(x, y, y / Math.sqrt(x));
        };
      }

      function Comm() {
        const listeners = [];

        this.emit = name => (listeners[name] || []).forEach(notify);

        this.on = (name, fn) => (listeners[name] = listeners[name] || []).push(fn);

        function notify(fn) {
          fn();
        }
      }
    </script>
  </body>
</html>